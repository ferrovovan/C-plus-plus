# Воплощение задачи "дилемма заключённого"
Это свободное ПО.

## Условие задачи:
Требуется реализовать консольное приложение, позволяющее симулировать повторяющуюся “Дилемму заключённого”
для троих заключённых.

### Устройство игры
1. Программа позволяет “соревноваться” трём “заключённым” (далее - стратегиям),
которые пытаются максимизировать набранные очки. 
Выигрывает стратегия, по результатам игры (некоторого фиксированного количества ходов) набравшая наибольшее количество очков.
2. Игра протекает следующим образом: пошагово, в течение некоторого количества шагов,
симулятор выясняет выбор каждой стратегии: сотрудничать (`C` cooperate) или предать (`D` defect).
После этого, симулятор сообщает каждой стратегии выбор её оппонентов и
вычисляет очки за текущий раунд.
Очки вычисляются по матрице игры (пример матрицы в приложении).
3. Стратегии делают свой выбор основываясь на накопленном опыте:
истории ходов оппонентов и собственной.
Алгоритмы стратегий могут быть самыми различными, 
начиная от тривиальных “всегда сотрудничать” или “выдавать случайный результат”.
Изначально, история ходов каждой стратегии пуста.
4. Симуляция может проходить в трёх режимах:
* Соревнование с детализацией.
На каждом шаге программа ожидает нажатия клавиши от пользователя,
после которого делает один шаг. 
Подробное состояние симуляции выводится после каждого шага
(выбор каждой стратегии, очки за текущий ход, очки за текущую игру).
Игра прерывается по команде quit.
* Соревнование без детализации. Программа вычисляет заданное количество ходов и выводит результат.
* Турнир. Программа перебирает все возможные тройки
(без повторений, т.е. `s1 s2 s3` и `s3 s2 s1` - одна и та же тройка)
указанных стратегий и по общему результату выявляет победителя по сумме баллов за все игры.
Результаты каждого соревнования и итоговый протокол выводятся на экран.

### Технические детали
1. На старте программе подаются следующие аргументы командной строки:
* Три (или более - для турнирного режима) имени соревнующихся стратегий;
* Название режима `--mode=[detailed|fast|tournament]`
(опциональный, по умолчанию - `detailed` для трех стратегий, `tournament` для >3 стратегий);
* Число шагов симуляции `--steps=<n>` (опциональный);
* Директория с конфигурационными файлами стратегий `--configs=<dirname>` (опциональный);
* Файл с матрицей игры `--matrix=<filename>` (опциональный);
2. Технически, каждая стратегия представляется в виде класса. 
У стратегий выделяется общий абстрактный интерфейс.
Нетривиальные стратегии хранят свои параметры в собственном конфигурационном файле произвольного формата.
3. При сдаче необходимо продемонстрировать 3-5 тривиальных и 3-5 нетривиальных стратегии,
включая “метастратегии” - использующие несколько других стратегий для принятия решения.
Сложность/интересность стратегий не ограничивается.
4. Для конструирования классов-стратегий следует использовать шаблон проектирования “Фабрика объектов”.
5. Матрица игры описывает количество очков, получаемых стратегиями за каждый ход.
Матрицу по умолчанию можно вшить в код программы.
Пример правильной матрицы для игры с тремя заключёнными содержится в приложении.
Формат файла с матрицей произволен.
6. При реализации программы подразумевается максимальное использование STL.
Для работы с файлами необходимо использовать файловые потоки,
переключенные в режим сообщения об ошибках исключениями (см. метод `std::ios::exceptions`).
7. Бизнес-логика симулятора должна быть покрыта модульными тестами.
8. При сдаче, преподаватель может потребовать интегрировать в симулятор
студента, стратегии другого учащегося и устроить турнир.
9. Поощряется реализация возможности динамической загрузки стратегий из динамических библиотек.
10. Базовая функциональность игры должна быть покрыта модульными тестами.

### Приложение. Матрица игры
| з1 | з2 | з3 |     | з1 | з2 | з3 |
|----|----|----|-----|----|----|----|
| С  | С  | С  | ==> | 7  | 7  | 7  |
| С  | С  | D  | ==> | 3  | 3  | 9  |
| С  | D  | С  | ==> | 3  | 9  | 3  |
| D  | С  | С  | ==> | 9  | 3  | 3  |
| С  | D  | D  | ==> | 0  | 5  | 5  |
| D  | С  | D  | ==> | 5  | 0  | 5  |
| D  | D  | С  | ==> | 5  | 5  | 0  |
| D  | D  | D  | ==> | 1  | 1  | 1  |


## Документация реализации
В данном разделе рассказывается логика программы. Решение задачи разбито на несколько частей:

### Симуляция
Программа моделирует поведение двух игроков, участвующих в дилемме заключённого, где каждый ход игрока зависит от выбранной стратегии. Основной компонент симуляции — класс `Simulation`, который управляет выполнением раундов игры и вычислением итоговых результатов.

### Взаимодействие с игровой матрицей
Класс `GameMatrix` представляет собой матрицу, которая используется для вычисления выигрышей и штрафов на основе выбранных ходов игроков. Взаимодействие с матрицей осуществляется через класс `MatrixReader`, который загружает данные матрицы из конфигурационных файлов.

### Использование истории ходов
Класс `History` отвечает за хранение информации о прошедших раундах игры. Это позволяет моделировать стратегию, основанную на предыдущем поведении оппонента. История хранит выборы игроков и используется стратегиями для принятия решений.

### Стратегии
Используется шаблон проектирования “Фабрика объектов” для создания экземпляров стратегий. Класс `StrategyFactory` отвечает за создание объектов различных стратегий, таких как:
- `AlwaysCooperate`
- `AlwaysDefect`
- `Eye4eye`
- `RandomChoice`

Каждая из этих стратегий реализует метод `decide`, который определяет поведение игрока на основе истории ходов.

### Обработка аргументов командной строки
Для обработки аргументов командной строки используется класс `CommandLineParser`, который позволяет пользователю настроить параметры симуляции, такие как количество раундов и выбор стратегий.

### Взаимодействие классов
Класс `Simulation` включает в себя композицией:
- `GameMatrix`
- `History`

При создании экземпляра симуляции использует фабрику стратегий для создания соответствующих стратегий для каждого игрока.

## Сборка проекта

Для сборки проекта используется система сборки CMake. Проект может быть собран на любой платформе, поддерживающей CMake.

### Необходимые зависимости
Для успешной сборки и работы проекта необходимо установить следующие зависимости:
- C++17 или более новая версия компилятора
- CMake 3.10 или более новая версия

### Установка зависимостей на Debian:
Для установки зависимостей на Debian используйте следующие команды:
```bash
sudo apt update
sudo apt install build-essential cmake g++
```
После установки зависимостей можно перейти к сборке и запуску проекта:
```
./scripts/build.sh 
./scripts/run.sh
```

## Лицензия
![GPLv3](./images/gplv3-127x51.png)  
Этот проект является свободным программным обеспечением.  
Это значит, что вы можете:
+ Использовать программу для любых целей без ограничений.
+ Изучать её исходный код и адаптировать программу под свои нужды.
+ Распространять копии программы среди других пользователей.
+ Модифицировать программу и распространять изменения, чтобы другие могли извлечь из них пользу.  

Полный текст лицензии доступен в файле [COPYING](./COPYING) и сайте проекта GNU: [GNU General Public License v3.0](https://www.gnu.org/licenses/gpl-3.0.html).

