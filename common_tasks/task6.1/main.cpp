#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <memory> // Для умных указателей
#include "Time.h"

// 1. Создание объекта в динамической памяти
int task_1() {
    std::cout << "Начало первого задания\n"; 
    // 1.1 Создание одного объекта через new
    Time* single_time = new Time();
    delete single_time; // Удаление для вызова деструктора

    // 1.2 Создание массива объектов через new[]
    Time* time_array = new Time[3];
    delete[] time_array; // Удаление массива

    // 1.3 Рукотворная утечка памяти
    // single_time = new Time();
    std::cout << "Конец первого задания\n";

    return 0;
}

// 2. Создание стандартных контейнеров с объектами типа Time
int task_2() {
    std::cout << "Начало второго задания\n";
    // Создание вектора объектов Time
    std::vector<Time> time_vector(3); // Три объекта создаются автоматически

    // Создание списка объектов Time
    std::list<Time> time_list(2); // Два объекта создаются автоматически
    
    // Создание очереди объектов Time
    std::deque<Time> time_deque(4); // Четыре объекта создаются автоматически
    
    std::cout << "Конец второго задания\n";
    return 0; // Деструкторы вызываются автоматически
}

// 3. Создание умных указателей
int task_3() {
    std::cout << "Начало третьего задания\n";
     // Создание unique_ptr
    std::unique_ptr<Time> unique_time = std::make_unique<Time>();

    // Создание shared_ptr
    std::shared_ptr<Time> shared_time = std::make_shared<Time>();

    // Создание shared_ptr на массив
    std::shared_ptr<Time[]> shared_array(new Time[4]); // Не поддерживает make_shared с массивом
    std::cout << "Конец третьего задания\n";

    return 0; // Умные указатели освободят память автоматически
}

// 4. Объяснение вывода
int task_4() {
    /*
    При использовании стандартных контейнеров и умных указателей освобождение ресурсов происходит автоматически:
    
    + Для std::vector и std::list деструкторы вызываются для всех элементов при выходе контейнера из области видимости.
    + Умные указатели (unique_ptr, shared_ptr) вызывают деструктор, как только теряют владельца. Для shared_ptr важно учитывать, что объект освобождается только при снижении счётчика ссылок до нуля.
    
    Важно:
      + Всегда ли требуется delete или delete[]?
      Нет, если используются умные указатели или стандартные контейнеры. В противном случае вызов delete и delete[] обязателен.
    */
    return 0;
}

int main() {
    task_1();
    task_2();
    task_3();
    // task_4();
    return 0; // Умные указатели освободят память автоматически
}
