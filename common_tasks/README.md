## Описание
Базовые задачи. Может быть "Задачи от лектора".

## Запуск
Чтобы проверить задание, нужно перейти в папку с номером задания и:
 - Или запустить скрипт, например ` ./run.sh `, ` ./scripts/run_tests.sh`
 - Или собрать проект через Makefile и запустить:
```
make
find . -type f -executable -print -exec ./{} +
```

## Условия задач:
### 1. Квадратное уравнение
Написать и вызвать функцию, решающую квадратное уравнение.

### 2. Общие буквы слов
Вам даны слова (вводите сами). Выведите в алфавитном порядке список общих букв всех слов.
**Формат входных данных:**
По одному слову в строке. Слова состоят из маленьких букв латинского алфавита.

**Формат выходных данных:**
Вывести в алфавитном порядке без пробелов список букв, которые присутствуют в каждом слове.

**Пример 1:**

**Вход:**  
`apple`  
`peach`  
`orange`

**Выход:**  
`ae`



### 3. Определение )объявление( Класса Time
**Исходный код:**
```
#include <iostream>

class Time {
private:
	int hours, minutes, seconds;
public:
	Time(){}; // defaults
	Time(int h, int m, int s): hours(h), minutes(m), seconds(s){}
	Time(const Time&); // конструктор копирования
	// делегирование конструктора
	Time(const Time& t): Time(t.hours, t.minutes, t.seconds){}

	Time& operator = (const Time& other){
		this->hours = other.hours; // явное указания на член класса
		minutes = other.minutes;   // неявное указание
		seconds = other.seconds;
		return *this;
	}

	Time& operator += (int s) {
		seconds += s;
		// Normalize();
		return *this;
	}

//    Time operator + (int s) const { // вариант "член класса"
//        return Time(hours, minutes, seconds + s);
//    } // Позволяет только "Time + int". Но имеет доступ к приватным полям объекта напрямую.

	Time operator + (const Time& t, int s) {  // вариант "внешняя функция"
		return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);
	} // Этот оператор позволяет только "Time + int", так как аргументы жёстко определены: первым должен быть объект Time, а вторым — int
	
	Time operator + (int s, const Time& t) {  // вариант "внешняя функция"
		return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);
	} // Добавление поддержки "int + Time"

	~Time(){} // деструктор

	int GetHours() const { return hours; }
	int GetMinutes() const { return minutes; }
	int GetSeconds() const { return seconds; }

	// void Normalize(); // реализовать
	// int ToSeconds() const; // реализовать

	void PrintTime(){
		std::cout << "H:" << this->GetHours()
			<< " M:" << this->GetMinutes()
			<< " S:" << this->GetSeconds()
			<< std::endl;
	}
};
```

**Задание:**  
Дополнить класс `Time`:
- методом `Normalize()`, нормализующим данные в классе `Time`, то есть приводя время в диапазон от `00:00:00` до `23:59:59`. Значения вне  диапазона младшего разряда изменяют значения старшего разряда.
- методом `ToSeconds()`, переводящим хранящееся значение времени в количество секунд. 
- операторами “-”, “-=” (по аналогии с “+” и “+=”) и “==”.

### 4. Расширение класса Time
1. Добавить в реализацию класса Time (см. предыдущее задание) счётчик созданных объектов. При создании объекта класса Time (конструкторы) счётчик увеличивается, в деструкторе - уменьшается.
2. Добавить в конструкторы (и деструктор) вывод сообщения о вызове данного конструктора. Дополнительно к наименованию конструктора вывести текущее количество (после создания конструктором или уничтожения деструктором) объектов данного класса (см. пункт 1).
3. Проанализировать сообщения выводимые следующей функцией:
```  
int main()
{
	Time t;
	t.SetHours(1);
	Time t2 = t;
	t2.SetHours(2);
	t2.PrintTime();
	{
		t2.SetHours(12);
		t2.PrintTime();
		Time t2(22, 22, 22);
		t2.PrintTime();
	}
	t2.PrintTime();
	Time t3(3, 3, 3);
	t3 = t;
	t3.SetHours(3);
	t3.PrintTime();
}
```
*Примечание:* Это буквально проверка добавленных возможностей.

### 5. использование CMake и GoogleTest
Продолжение работы с классом Time:
1. Собрать с использованием CMake.
2. Добавить тестирование (googletest в отдельной директории) на каждый конструктор, оператор и функцию (от 3 групп тестов). Сделать намеренно несколько тестов провальными.
3. Организовать возможность сборки без тестов (выбор на этапе конфигурирования)

