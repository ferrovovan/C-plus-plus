## Описание
Базовые задачи. Может быть "Задачи от лектора".

## Запуск
Чтобы проверить задание, нужно перейти в папку с номером задания и:
 - Или запустить скрипт, например ` ./run.sh `, ` ./scripts/run_tests.sh`
 - Или собрать проект через Makefile и запустить:
```
make
find . -type f -executable -print -exec ./{} +
```
 - Или через CMake:
```
./scripts/build.sh
find ./build -type f -executable -print -exec ./{} +
```

## Условия задач:
### 1. Квадратное уравнение
Написать и вызвать функцию, решающую квадратное уравнение.

### 2. Общие буквы слов
Вам даны слова (вводите сами). Выведите в алфавитном порядке список общих букв всех слов.
**Формат входных данных:**
По одному слову в строке. Слова состоят из маленьких букв латинского алфавита.

**Формат выходных данных:**
Вывести в алфавитном порядке без пробелов список букв, которые присутствуют в каждом слове.

**Пример 1:**

**Вход:**  
`apple`  
`peach`  
`orange`

**Выход:**  
`ae`



### 3. Определение )объявление( Класса Time
**Исходный код:**
```
#include <iostream>

class Time {
private:
	int hours, minutes, seconds;
public:
	Time(){}; // defaults
	Time(int h, int m, int s): hours(h), minutes(m), seconds(s){}
	Time(const Time&); // конструктор копирования
	// делегирование конструктора
	Time(const Time& t): Time(t.hours, t.minutes, t.seconds){}

	Time& operator = (const Time& other){
		this->hours = other.hours; // явное указания на член класса
		minutes = other.minutes;   // неявное указание
		seconds = other.seconds;
		return *this;
	}

	Time& operator += (int s) {
		seconds += s;
		// Normalize();
		return *this;
	}

//    Time operator + (int s) const { // вариант "член класса"
//        return Time(hours, minutes, seconds + s);
//    } // Позволяет только "Time + int". Но имеет доступ к приватным полям объекта напрямую.

	Time operator + (const Time& t, int s) {  // вариант "внешняя функция"
		return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);
	} // Этот оператор позволяет только "Time + int", так как аргументы жёстко определены: первым должен быть объект Time, а вторым — int
	
	Time operator + (int s, const Time& t) {  // вариант "внешняя функция"
		return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);
	} // Добавление поддержки "int + Time"

	~Time(){} // деструктор

	int GetHours() const { return hours; }
	int GetMinutes() const { return minutes; }
	int GetSeconds() const { return seconds; }

	// void Normalize(); // реализовать
	// int ToSeconds() const; // реализовать

	void PrintTime(){
		std::cout << "H:" << this->GetHours()
			<< " M:" << this->GetMinutes()
			<< " S:" << this->GetSeconds()
			<< std::endl;
	}
};
```

**Задание:**  
Дополнить класс `Time`:
- методом `Normalize()`, нормализующим данные в классе `Time`, то есть приводя время в диапазон от `00:00:00` до `23:59:59`. Значения вне  диапазона младшего разряда изменяют значения старшего разряда.
- методом `ToSeconds()`, переводящим хранящееся значение времени в количество секунд. 
- операторами “-”, “-=” (по аналогии с “+” и “+=”) и “==”.

### 4. Расширение класса Time
1. Добавить в реализацию класса Time (см. предыдущее задание) счётчик созданных объектов. При создании объекта класса Time (конструкторы) счётчик увеличивается, в деструкторе - уменьшается.
2. Добавить в конструкторы (и деструктор) вывод сообщения о вызове данного конструктора. Дополнительно к наименованию конструктора вывести текущее количество (после создания конструктором или уничтожения деструктором) объектов данного класса (см. пункт 1).
3. Проанализировать сообщения выводимые следующей функцией:
```  
int main()
{
	Time t;
	t.SetHours(1);
	Time t2 = t;
	t2.SetHours(2);
	t2.PrintTime();
	{
		t2.SetHours(12);
		t2.PrintTime();
		Time t2(22, 22, 22);
		t2.PrintTime();
	}
	t2.PrintTime();
	Time t3(3, 3, 3);
	t3 = t;
	t3.SetHours(3);
	t3.PrintTime();
}
```
*Примечание:* Это буквально проверка добавленных возможностей.

### 5. Использование CMake и GTest
Продолжение работы с классом Time:
1. Собрать с использованием CMake.
2. Добавить тестирование (через GoogleTest ) на каждый конструктор, оператор и функцию (от 3 групп тестов). Сделать намеренно несколько тестов провальными.
3. Организовать возможность сборки без тестов (выбор на этапе конфигурации)

### 6.1. Создание объектов класса Time в динамической памяти:
#### Теория  
**Классическая работа с памятью**  
Операторы:
- Освобождение - `delete`, `delete[]`
- Создание - `new`, `new[]`  
Потенциальные проблемы:
- Утечка объектов (`new` без `delete`)
- Преждевременное удаление
- Двойное удаление

**Современный подход с использованием RAII**  
В отличие от классической работы с памятью, где управление ресурсами возлагается на программиста,  
идиома RAII (Resource Acquisition Is Initialization) автоматизирует этот процесс,  
связывая жизненный цикл ресурса с жизненным циклом объекта.  

Ключевые принципы:  
- Захват ресурса при создании объекта (конструктор) и его освобождение при уничтожении (деструктор), что исключает утечки памяти и двойное освобождение.  
- Управление ресурсами ограничивается областью видимости, что снижает риск преждевременного удаления.  

Более удачные названия идиомы (по Бьярне Страуструпу):  
- CADR (Constructor Acquires, Destructor Releases) — конструктор захватывает, деструктор освобождает.  
- SBRM (Scope-Bound Resource Management) — управление ресурсами с привязкой к области видимости.  


**Примеры использования**
- Единоличный "умный" указатель `std::unique_ptr`  
Только один объект может владеть этим указателем и управлять ресурсом.
```
#include <memory> // для умных указателей
int main() {
    int* ptr = new int(17); // обычный указатель
    delete ptr; // важно не забыть!
    
    // А это — умный указатель
    std::unique_ptr<int> smart = std::make_unique<int>(17); // вместо new int(17)
    //эквивалентно  std::unique_ptr<int> smart { std::make_unique<int>(17) };

    // Можно работать как с обычным указателем — у него перегружены соответствующие операторы:
    std::cout << *smart << "\n"; // 17
    // auto ptr2 = ptr1; // копирование запрещено
    // ptr.reset(); // устанавливает nullptr
    
    unsigned n{5}; // размер массива
    auto pnumbers { std::make_unique<int[]>(n) }; // массив {0, 0, 0, 0, 0}    
    pnumbers[1] = 11; // изменяем значение
}
// вызывать delete не надо, выделенная память освободится при выходе из блока
```

- Общий "умный" указатель `std::shared_ptr`  
Предоставляет совместное владение ресурсом, где несколько указателей могут одновременно владеть одним объектом.  
Освобождение ресурса происходит автоматически, когда последний `std::shared_ptr`, связанный с этим объектом, уничтожается или переназначается.
```
#include <iostream> // для ввода-вывода
#include <memory> // для умных указателей
int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(17);
    std::cout << *ptr1 << "\n"; // 17
    std::cout << ptr1.use_count() << "\n"; // 1
    auto ptr2 = ptr1; // копирование разрешено!
    std::cout << *ptr1 << "\n"; // 17
    std::cout << *ptr2 << "\n"; // 17 — это всё тот же объект
    std::cout << ptr1.use_count() << "\n"; // 2
    std::cout << ptr2.use_count() << "\n"; // 2
    std::shared_ptr<int> ptr3;
    std::cout << ptr3.use_count() << "\n"; // 0
    
    ptr3 = ptr1; // присваивание тоже разрешено!
    std::cout << *ptr3 << "\n"; // 17
    std::cout << ptr1.use_count() << "\n"; // 3
    std::cout << ptr2.use_count() << "\n"; // 3
    std::cout << ptr3.use_count() << "\n"; // 3
}
```
*Примечание:* Для подключения умных указателей использовать `#include <memory>`.

#### Задания  
1. Дополнительно создать объекты класса `Time` в динамической памяти ( с помощью `new` и `new[]`)(как один экземпляр, так и массив небольшого размера).
2. Создать стандартные контейнеры (`std::vector`, `std::list`, `std::deque` и другие), содержащие объекты типа `Time`.
3. Создать умные указатели (*shared* и *unique*) на объекты класса `Time`.
4. Изучить и объяснить вывод сообщений конструкторов и деструкторов. Обратить внимание на необходимость (всегда ли?) вызова `delete` и/или `delete[]`.


### 6.2. Обработка ошибок
